/**
 * ============================================================
 * Script 2: Inject strategies CSV into the database
 * ============================================================
 * 
 * Reads the CSV generated by generate-strategies-csv.ts and
 * inserts all rows into the `strategies` table.
 * 
 * INPUT: scripts/output/strategies_seed.csv
 *
 * Usage:
 *   npx tsx scripts/inject-strategies-csv.ts                  # Insert, skip duplicates
 *   npx tsx scripts/inject-strategies-csv.ts --dry-run        # Preview only, no DB writes
 *   npx tsx scripts/inject-strategies-csv.ts --clean-first    # Delete ALL showcase strategies, then insert
 *   npx tsx scripts/inject-strategies-csv.ts --csv path.csv   # Use a different CSV file
 * 
 * Behavior:
 *   - Skips rows where config_hash already exists in the DB (deduplication)
 *   - With --clean-first: deletes all strategies where is_showcase = true before inserting
 *   - Does not increment saved_strategies_count on the user (these are system-generated)
 */

import * as fs from 'fs';
import * as path from 'path';
import dotenv from 'dotenv';

// Load .env.local
dotenv.config({ path: path.join(__dirname, '..', '.env.local') });

import { db } from '../db';
import { strategies } from '../db/schema';
import { eq, and } from 'drizzle-orm';

// ============================================
// Configuration
// ============================================
const DEFAULT_CSV = path.join(__dirname, 'output', 'strategies_seed.csv');

// ============================================
// CSV Parser (handles quoted fields with commas and escaped quotes)
// ============================================

/**
 * Parse a single CSV line respecting quoted fields.
 * Handles: "field with ""escaped"" quotes", "field, with comma"
 */
function parseCsvLine(line: string): string[] {
    const fields: string[] = [];
    let current = '';
    let inQuotes = false;
    let i = 0;

    while (i < line.length) {
        const char = line[i];

        if (inQuotes) {
            if (char === '"') {
                // Check for escaped quote ""
                if (i + 1 < line.length && line[i + 1] === '"') {
                    current += '"';
                    i += 2;
                    continue;
                } else {
                    // End of quoted field
                    inQuotes = false;
                    i++;
                    continue;
                }
            } else {
                current += char;
                i++;
            }
        } else {
            if (char === '"') {
                inQuotes = true;
                i++;
            } else if (char === ',') {
                fields.push(current);
                current = '';
                i++;
            } else {
                current += char;
                i++;
            }
        }
    }

    fields.push(current); // Last field
    return fields;
}

/**
 * Parse the entire CSV file into an array of objects.
 */
function parseCsv(filePath: string): Record<string, string>[] {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n').filter(l => l.trim().length > 0);

    if (lines.length < 2) {
        throw new Error('CSV file has no data rows');
    }

    const headers = parseCsvLine(lines[0]);
    const rows: Record<string, string>[] = [];

    for (let i = 1; i < lines.length; i++) {
        const values = parseCsvLine(lines[i]);
        const row: Record<string, string> = {};

        for (let j = 0; j < headers.length; j++) {
            row[headers[j]] = values[j] ?? '';
        }

        rows.push(row);
    }

    return rows;
}

// ============================================
// Main
// ============================================
async function main() {
    const args = process.argv.slice(2);
    const isDryRun = args.includes('--dry-run');
    const cleanFirst = args.includes('--clean-first');
    const csvIdx = args.indexOf('--csv');
    const csvPath = csvIdx !== -1 ? args[csvIdx + 1] : DEFAULT_CSV;

    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('  ðŸ’‰ Strategy CSV Injector');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`ðŸ“„ CSV:    ${csvPath}`);
    console.log(`ðŸ”§ Mode:   ${isDryRun ? 'DRY RUN' : cleanFirst ? 'CLEAN + INSERT' : 'INSERT (skip duplicates)'}`);
    console.log('');

    if (!fs.existsSync(csvPath)) {
        console.error(`âŒ CSV file not found: ${csvPath}`);
        console.error('   Run generate-strategies-csv.ts first.');
        process.exit(1);
    }

    // Parse CSV
    const rows = parseCsv(csvPath);
    console.log(`ðŸ“Š Parsed ${rows.length} rows from CSV`);

    if (isDryRun) {
        console.log('\nðŸ“‹ Preview (first 5 rows):');
        for (const row of rows.slice(0, 5)) {
            console.log(`  - ${row.name} | hash: ${row.config_hash} | return: ${row.total_return || 'N/A'}% | quality: ${row.quality_score}`);
        }
        console.log(`\nâœ… DRY RUN complete. ${rows.length} rows would be inserted.`);
        process.exit(0);
    }

    // Clean existing showcase strategies if requested
    if (cleanFirst) {
        console.log('ðŸ§¹ Deleting existing showcase strategies...');
        const deleted = await db.delete(strategies)
            .where(eq(strategies.isShowcase, true))
            .returning({ id: strategies.id });
        console.log(`   Deleted ${deleted.length} existing showcase strategies.`);
        console.log('');
    }

    // Insert rows
    let inserted = 0;
    let skipped = 0;
    let errors = 0;

    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const name = row.name;
        const configHash = row.config_hash;

        try {
            // Check for existing strategy with same config_hash (skip duplicates)
            if (!cleanFirst) {
                const existing = await db.query.strategies.findFirst({
                    where: eq(strategies.configHash, configHash),
                });

                if (existing) {
                    console.log(`  [${i + 1}/${rows.length}] â­ï¸  "${name}" (hash ${configHash} exists, id: ${existing.id})`);
                    skipped++;
                    continue;
                }
            }

            // Parse JSON fields
            let config: any;
            try {
                config = JSON.parse(row.config);
            } catch {
                console.error(`  [${i + 1}/${rows.length}] âŒ "${name}" - Invalid JSON in config column`);
                errors++;
                continue;
            }

            let topHoldings: any = null;
            try {
                const parsed = JSON.parse(row.top_holdings);
                topHoldings = Array.isArray(parsed) && parsed.length > 0 ? parsed : null;
            } catch {
                topHoldings = null;
            }

            // Insert into DB
            const [newStrategy] = await db.insert(strategies).values({
                creatorId: row.creator_id,
                name: row.name,
                description: row.description || null,
                configHash: row.config_hash,
                config,
                totalReturn: row.total_return || null,
                maxDrawdown: row.max_drawdown || null,
                successRate: row.success_rate || null,
                sharpeRatio: row.sharpe_ratio || null,
                totalTrades: row.total_trades ? parseInt(row.total_trades) : 0,
                totalStocks: row.total_stocks ? parseInt(row.total_stocks) : 0,
                qualityScore: row.quality_score || 'Unknown',
                subscribers: 0,
                topHoldings,
                isPublic: row.is_public === 'true',
                isActive: row.is_active === 'true',
                isShowcase: row.is_showcase === 'true',
            }).returning();

            console.log(`  [${i + 1}/${rows.length}] âœ… "${name}" (id: ${newStrategy.id})`);
            inserted++;

        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Unknown error';
            console.error(`  [${i + 1}/${rows.length}] âŒ "${name}" - ${msg}`);
            errors++;
        }
    }

    console.log('');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`  âœ… Inserted: ${inserted}`);
    console.log(`  â­ï¸  Skipped:  ${skipped}`);
    console.log(`  âŒ Errors:   ${errors}`);
    console.log(`  ðŸ“‚ Total:    ${rows.length}`);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    process.exit(errors > 0 ? 1 : 0);
}

main().catch(err => {
    console.error('Fatal:', err);
    process.exit(1);
});
