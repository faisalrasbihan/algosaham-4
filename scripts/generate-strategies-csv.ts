/**
 * ============================================================
 * Script 1: Generate strategies CSV from best_variation JSONs
 * ============================================================
 * 
 * This reads all JSON files from docs/best_variation/, calls the
 * Railway backtest API for each, and writes a CSV containing all
 * the columns needed for the `strategies` DB table.
 * 
 * OUTPUT: scripts/output/strategies_seed.csv
 * 
 * Usage:
 *   npx tsx scripts/generate-strategies-csv.ts
 *   npx tsx scripts/generate-strategies-csv.ts --dry-run     # Skip API calls, preview only
 *   npx tsx scripts/generate-strategies-csv.ts --retry-only   # Only retry rows with errors
 * 
 * The CSV columns match the `strategies` table in db/schema.ts:
 *   creator_id, name, description, config_hash, config,
 *   total_return, max_drawdown, success_rate, sharpe_ratio,
 *   total_trades, total_stocks, quality_score, subscribers,
 *   top_holdings, is_public, is_active, is_showcase
 * 
 * Note: `id`, `created_at`, `updated_at` are auto-generated by Postgres.
 */

import * as fs from 'fs';
import * as path from 'path';
import crypto from 'crypto';
import dotenv from 'dotenv';

// Load .env.local
dotenv.config({ path: path.join(__dirname, '..', '.env.local') });

// ============================================
// Configuration
// ============================================
const BEST_VARIATION_DIR = path.join(__dirname, '..', 'docs', 'best_variation');
const OUTPUT_DIR = path.join(__dirname, 'output');
const OUTPUT_CSV = path.join(OUTPUT_DIR, 'strategies_seed.csv');
const ERROR_LOG = path.join(OUTPUT_DIR, 'strategies_errors.log');

const RAILWAY_URL = (() => {
    const raw = process.env.RAILWAY_URL || '';
    return raw.startsWith('http') ? raw : `https://${raw}`;
})();

const CREATOR_ID = 'system_showcase'; // The system user for showcase strategies
const DELAY_BETWEEN_REQUESTS_MS = 2000; // 2s between API calls

// ============================================
// Types
// ============================================

/** Raw JSON structure from best_variation files */
interface RawJsonConfig {
    backtestId: string;
    filters: {
        marketCap?: string[];
        syariah?: boolean;
        minDailyValue?: number;
        tickers?: string[];
        sectors?: string[];
    };
    fundamentalIndicators: Array<{
        type: string;
        min?: number;
        max?: number;
    }>;
    technicalIndicators: Array<{
        type: string;
        [key: string]: any;
    }>;
    backtestConfig: {
        initialCapital: number;
        startDate: string;
        endDate: string;
        tradingCosts: {
            brokerFee: number;
            sellFee: number;
            minimumFee: number;
            slippageBps?: number;
            spreadBps?: number;
        };
        portfolio: {
            positionSizePercent: number;
            minPositionPercent: number;
            maxPositions: number;
        };
        riskManagement: {
            maxHoldingDays: number;
            stopLoss: {
                method: string;
                percent?: number;
                atrMultiplier?: number;
                atrPeriod?: number;
            };
            takeProfit: {
                method: string;
                percent?: number;
                riskRewardRatio?: number;
            };
        };
    };
}

/** Config format expected by the Railway /run_backtest API */
interface ApiConfig {
    backtestId: string;
    filters: Record<string, any>;
    fundamentalIndicators: any[];
    technicalIndicators: any[];
    backtestConfig: {
        initialCapital: number;
        startDate: string;
        endDate: string;
        tradingCosts: {
            brokerFee: number;
            sellFee: number;
            minimumFee: number;
        };
        portfolio: {
            positionSizePercent: number;
            minPositionPercent: number;
            maxPositions: number;
        };
        riskManagement: {
            stopLossPercent: number;
            takeProfitPercent: number;
            maxHoldingDays: number;
        };
    };
}

/** One row in our CSV output */
interface CsvRow {
    creator_id: string;
    name: string;
    description: string;
    config_hash: string;
    config: string;          // JSON-stringified
    total_return: string;     // numeric as string, e.g. "87.5"
    max_drawdown: string;     // numeric as string, e.g. "-17.38"
    success_rate: string;     // numeric as string (win rate)
    sharpe_ratio: string;     // numeric as string
    total_trades: string;     // integer as string
    total_stocks: string;     // integer as string
    quality_score: string;    // "Poor", "Good", "Excellent", "Unknown"
    subscribers: string;      // always "0"
    top_holdings: string;     // JSON-stringified array
    is_public: string;        // "true" / "false"
    is_active: string;        // "true" / "false"
    is_showcase: string;      // "true" / "false"
}

// ============================================
// Helper Functions
// ============================================

/**
 * Extract a human-readable strategy name from backtestId.
 * 
 * Examples:
 *   "adx_trend_value_pe_period14_threshold20_max15"    -> "ADX Trend Value PE"
 *   "accumulation_distribution_v0"                       -> "Accumulation Distribution V0"
 *   "sma_crossover_syariah_atr_risk_shortPeriod30_..."  -> "SMA Crossover Syariah ATR Risk"
 *   "bollinger_bounce_base_period20_stdDev1.8"           -> "Bollinger Bounce Base"
 * 
 * Logic:
 * 1. Split by underscore
 * 2. Walk through parts, collecting them as "name" words
 * 3. Stop when we hit a part that looks like a parameter key+value 
 *    (e.g. "period14", "threshold20", "max15", "shortPeriod30")
 * 4. Title-case words; uppercase known abbreviations
 */
function extractStrategyName(backtestId: string): string {
    const parts = backtestId.split('_');

    // Parameter prefixes: if a part starts with one of these followed by a digit/value, it's a param
    const paramPrefixes = [
        'period', 'threshold', 'max', 'min', 'shortperiod', 'longperiod',
        'stddev', 'fastperiod', 'slowperiod', 'signalperiod', 'baseperiod',
        'breakoutpct', 'afmax', 'afstep', 'multiplier', 'kperiod', 'dperiod',
        'signalwindow', 'oversold', 'mindailyvalue', 'lookback', 'mode',
        'atrmultiplier', 'riskrewardratio', 'atrperiod', 'highthreshold',
        'lowthreshold',
    ];

    // Known abbreviations to uppercase
    const abbreviations = new Set([
        'adx', 'pe', 'pbv', 'roe', 'ema', 'sma', 'rsi', 'macd', 'obv', 'sar',
        'vpt', 'vwap', 'atr', 'v0',
    ]);

    const nameParts: string[] = [];

    for (const part of parts) {
        const lower = part.toLowerCase();

        // Check if this looks like a parameter (prefix followed by a number, e.g. "period14")
        const isParamWithValue = paramPrefixes.some(prefix =>
            lower.startsWith(prefix) && lower.length > prefix.length && /\d/.test(lower.charAt(prefix.length))
        );

        if (isParamWithValue) break;

        // Pure number = param value, stop
        if (/^\d+(\.\d+)?$/.test(lower)) break;

        // Capitalize the word
        if (abbreviations.has(lower)) {
            nameParts.push(lower.toUpperCase());
        } else if (/^v\d+$/.test(lower)) {
            nameParts.push(lower.toUpperCase());
        } else {
            nameParts.push(lower.charAt(0).toUpperCase() + lower.slice(1));
        }
    }

    return nameParts.join(' ') || backtestId;
}

/**
 * Transform the raw JSON config to the format accepted by the Railway API.
 * 
 * Key transformations:
 * - riskManagement.stopLoss.percent  -> riskManagement.stopLossPercent
 * - riskManagement.takeProfit.percent -> riskManagement.takeProfitPercent
 * - Strips extra fields (slippageBps, spreadBps)
 * 
 * Edge case: ATR/RISK_REWARD strategies don't have a `percent` field.
 *   In that case we default to 0 (the Railway backend still accepts this
 *   and uses its own ATR-based calculation internally).
 */
function transformConfigForApi(raw: RawJsonConfig): ApiConfig {
    return {
        backtestId: raw.backtestId,
        filters: raw.filters,
        fundamentalIndicators: raw.fundamentalIndicators || [],
        technicalIndicators: raw.technicalIndicators || [],
        backtestConfig: {
            initialCapital: raw.backtestConfig.initialCapital,
            startDate: raw.backtestConfig.startDate,
            endDate: raw.backtestConfig.endDate,
            tradingCosts: {
                brokerFee: raw.backtestConfig.tradingCosts.brokerFee,
                sellFee: raw.backtestConfig.tradingCosts.sellFee,
                minimumFee: raw.backtestConfig.tradingCosts.minimumFee,
            },
            portfolio: raw.backtestConfig.portfolio,
            riskManagement: {
                stopLossPercent: raw.backtestConfig.riskManagement.stopLoss?.percent ?? 0,
                takeProfitPercent: raw.backtestConfig.riskManagement.takeProfit?.percent ?? 0,
                maxHoldingDays: raw.backtestConfig.riskManagement.maxHoldingDays,
            },
        },
    };
}

/**
 * Generate a SHA256 hash (first 16 hex chars) from the raw JSON config.
 * We hash the RAW config (not transformed) so it's a unique fingerprint
 * of the original strategy definition.
 */
function generateConfigHash(rawConfig: RawJsonConfig): string {
    const configString = JSON.stringify(rawConfig);
    return crypto.createHash('sha256').update(configString).digest('hex').substring(0, 16);
}

/**
 * Calculate quality score from Sharpe ratio.
 */
function calculateQualityScore(sharpeRatio: number | null): string {
    if (sharpeRatio === null || sharpeRatio === undefined) return 'Unknown';
    if (sharpeRatio < 1.0) return 'Poor';
    if (sharpeRatio <= 2.0) return 'Good';
    return 'Excellent';
}

/**
 * Extract top 3 stock holdings from backtest signals (most recent first).
 */
function extractTopHoldings(backtestResults: any): { symbol: string; color: string }[] {
    const allSignals =
        backtestResults?.recentSignals?.signals ||
        backtestResults?.signals ||
        [];

    if (!Array.isArray(allSignals) || allSignals.length === 0) return [];

    // Sort by date descending
    const sorted = [...allSignals].sort(
        (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
    );

    const colors = ['bg-blue-600', 'bg-orange-500', 'bg-green-600', 'bg-purple-600', 'bg-red-600'];
    const seen = new Set<string>();
    const holdings: { symbol: string; color: string }[] = [];

    for (const sig of sorted) {
        if (holdings.length >= 3) break;
        if (!seen.has(sig.ticker)) {
            seen.add(sig.ticker);
            holdings.push({
                symbol: sig.ticker,
                color: colors[holdings.length] || 'bg-gray-600',
            });
        }
    }

    return holdings;
}

/**
 * Count unique stocks from backtest signals.
 */
function countUniqueStocks(backtestResults: any): number {
    const allSignals =
        backtestResults?.recentSignals?.signals ||
        backtestResults?.signals ||
        [];

    if (!Array.isArray(allSignals) || allSignals.length === 0) return 0;
    return new Set(allSignals.map((s: any) => s.ticker)).size;
}

/**
 * Call Railway /run_backtest directly.
 */
async function callBacktestApi(config: ApiConfig): Promise<any> {
    const response = await fetch(`${RAILWAY_URL}/run_backtest`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ config }),
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API ${response.status}: ${errorText.substring(0, 300)}`);
    }

    return response.json();
}

/**
 * Escape a value for CSV. 
 * Wraps in double quotes and escapes internal double quotes.
 */
function csvEscape(val: string): string {
    // Always wrap in quotes to handle commas, newlines, etc.
    return `"${val.replace(/"/g, '""')}"`;
}

function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ============================================
// CSV Column Headers (match strategies table)
// ============================================
const CSV_HEADERS = [
    'creator_id',
    'name',
    'description',
    'config_hash',
    'config',
    'total_return',
    'max_drawdown',
    'success_rate',
    'sharpe_ratio',
    'total_trades',
    'total_stocks',
    'quality_score',
    'subscribers',
    'top_holdings',
    'is_public',
    'is_active',
    'is_showcase',
];

// ============================================
// Main
// ============================================
async function main() {
    const args = process.argv.slice(2);
    const isDryRun = args.includes('--dry-run');

    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('  üìä Strategy CSV Generator');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    if (!RAILWAY_URL || RAILWAY_URL === 'https://') {
        console.error('‚ùå RAILWAY_URL not set. Check .env.local');
        process.exit(1);
    }

    // Ensure output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Read all JSON files
    const files = fs.readdirSync(BEST_VARIATION_DIR)
        .filter(f => f.endsWith('.json'))
        .sort();

    console.log(`üìÇ Found ${files.length} strategy files`);
    console.log(`üîß Mode: ${isDryRun ? 'DRY RUN (no API calls)' : 'FULL RUN'}`);
    console.log(`üåê Railway: ${RAILWAY_URL}`);
    console.log(`üë§ Creator: ${CREATOR_ID}`);
    console.log(`üìù Output:  ${OUTPUT_CSV}`);
    console.log('');

    // Prepare CSV output
    const csvLines: string[] = [CSV_HEADERS.join(',')];
    const errors: string[] = [];
    let successCount = 0;

    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const filePath = path.join(BEST_VARIATION_DIR, file);

        process.stdout.write(`[${i + 1}/${files.length}] ${file} `);

        try {
            // 1. Read & parse JSON
            const raw: RawJsonConfig = JSON.parse(fs.readFileSync(filePath, 'utf-8'));

            // 2. Extract name from backtestId
            const name = extractStrategyName(raw.backtestId);

            // 3. Generate config hash (from raw config, not transformed)
            const configHash = generateConfigHash(raw);

            // 4. Transform for API call
            const apiConfig = transformConfigForApi(raw);

            if (isDryRun) {
                // In dry run, fill in placeholder metrics
                const row: CsvRow = {
                    creator_id: CREATOR_ID,
                    name,
                    description: `Showcase strategy: ${name}`,
                    config_hash: configHash,
                    config: JSON.stringify(raw), // Store the ORIGINAL raw JSON
                    total_return: '',
                    max_drawdown: '',
                    success_rate: '',
                    sharpe_ratio: '',
                    total_trades: '0',
                    total_stocks: '0',
                    quality_score: 'Unknown',
                    subscribers: '0',
                    top_holdings: '[]',
                    is_public: 'true',
                    is_active: 'true',
                    is_showcase: 'true',
                };

                csvLines.push(CSV_HEADERS.map(h => csvEscape((row as any)[h])).join(','));
                console.log(`-> "${name}" [DRY RUN]`);
                successCount++;
                continue;
            }

            // 5. Call backtest API
            const result = await callBacktestApi(apiConfig);

            // 6. Extract metrics
            const totalReturn = result.summary?.totalReturn ?? null;
            const maxDrawdown = result.summary?.maxDrawdown ?? null;
            const winRate = result.summary?.winRate ?? null;
            const sharpeRatio = result.summary?.sharpeRatio ?? null;
            const totalTrades = result.summary?.totalTrades ?? 0;
            const totalStocks = countUniqueStocks(result);
            const qualityScore = calculateQualityScore(sharpeRatio);
            const topHoldings = extractTopHoldings(result);

            // 7. Build CSV row
            const row: CsvRow = {
                creator_id: CREATOR_ID,
                name,
                description: `Showcase strategy: ${name}`,
                config_hash: configHash,
                config: JSON.stringify(raw), // Store ORIGINAL raw JSON as the config
                total_return: totalReturn !== null ? String(totalReturn) : '',
                max_drawdown: maxDrawdown !== null ? String(maxDrawdown) : '',
                success_rate: winRate !== null ? String(winRate) : '',
                sharpe_ratio: sharpeRatio !== null ? String(sharpeRatio) : '',
                total_trades: String(totalTrades),
                total_stocks: String(totalStocks),
                quality_score: qualityScore,
                subscribers: '0',
                top_holdings: JSON.stringify(topHoldings),
                is_public: 'true',
                is_active: 'true',
                is_showcase: 'true',
            };

            csvLines.push(CSV_HEADERS.map(h => csvEscape((row as any)[h])).join(','));
            console.log(`-> "${name}" | ${totalReturn ?? 'N/A'}% | ${totalTrades} trades | ${qualityScore}`);
            successCount++;

            // Delay
            if (i < files.length - 1) {
                await sleep(DELAY_BETWEEN_REQUESTS_MS);
            }

        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Unknown error';
            console.log(`-> ‚ùå ${msg}`);
            errors.push(`${file}: ${msg}`);
        }
    }

    // Write CSV
    fs.writeFileSync(OUTPUT_CSV, csvLines.join('\n'), 'utf-8');
    console.log('');
    console.log(`‚úÖ CSV written to: ${OUTPUT_CSV}`);
    console.log(`   Rows: ${csvLines.length - 1} (header + ${successCount} data rows)`);

    // Write error log if any
    if (errors.length > 0) {
        fs.writeFileSync(ERROR_LOG, errors.join('\n'), 'utf-8');
        console.log(`‚ùå Errors: ${errors.length} (see ${ERROR_LOG})`);
    }

    console.log('');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`  ‚úÖ ${successCount} succeeded | ‚ùå ${errors.length} failed | üìÇ ${files.length} total`);
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    process.exit(errors.length > 0 ? 1 : 0);
}

main().catch(err => {
    console.error('Fatal:', err);
    process.exit(1);
});
